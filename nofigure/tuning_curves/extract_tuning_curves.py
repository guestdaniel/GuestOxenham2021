"""
This script takes estimates of firing rates at ranges of frequencies and levels for a given CF generated by
estimate_freq_level_functions.py and fits a tuning curve to them. These tuning curves are saved to disk for further use.
"""
from scipy.interpolate import interp1d, interp2d
import numpy as np
import config as cfg
import os
from skimage import measure


def fit_tuning_curve(levels, freqs, firing_rates, criterion, cf):
    """
    Take an array of firing rates where each element is the mean firing rate for a pure tone of a given frequency and
    level,

    Parameters:
        levels (ndarray): 1d array of levels corresponding to elements of firing_rates, in dB SPL
        freqs (ndarray): 1d array of frequencies corresponding to elements of firing_rates, in octaves re: CF
        firing_rates (ndarray): array where each element is the mean firing rate to a pure tone of a given frequency
            and level, of shape (n_level, n_freq)
        criterion (float): firing rate criterion for tuning curve, proportion of spontaneous firing rate
        cf (float): characteristic frequency of the neuron

    Returns:
        freqs (ndarray): 1d array that is interpolated copy of freqs, in Hz
        tuning_curve (ndarray): 1d array of levels in dB SPL of the tuning curve at corresponding frequencies in freqs,
            of same size as freqs
    """
    # First, upsample firing rate pattern by factor of 5 in frequency and levels
    freqs = np.log10(cf*2**freqs)  # transform freqs from octaves to log10(Hz)
    interpolator = interp2d(freqs, levels, firing_rates)  # construct interpolator for firing_rates
    freqs_up = np.linspace(np.min(freqs), np.max(freqs), len(freqs) * 5)  # upsample freqs by factor of 5
    levels_up = np.linspace(np.min(levels), np.max(levels), len(levels) * 5)  # upsample levels by factor of 5
    fr_up = interpolator(freqs_up, levels_up)  # upsample firing rates by factor of 5

    # Now, measure curve
    curve = measure.find_contours(fr_up, np.min(fr_up) * criterion)[0]  # measure curve at criterion
    curve_freqs = 10 ** interp1d(np.arange(0, len(freqs_up)), freqs_up)(curve[:, 1])  # extract frequencies
    curve_levels = interp1d(np.arange(0, len(levels_up)), levels_up)(curve[:, 0])  # extract levels

    return curve_freqs, curve_levels


# Import freq-level firing rate patterns from disk
cfs = np.load('nofigure/tuning_curves/cfs.npy')
freqs = np.load('nofigure/tuning_curves/freqs.npy')
levels = np.load('nofigure/tuning_curves/levels.npy')

# Create storage and loop through and fit tuning curves
for model_name in ['Heinz2001', 'Zilany2014']:
    tuning_curves = list()
    firing_rates = np.load(os.path.join('nofigure/tuning_curves/', model_name + '.npy'))
    for fr, cf in zip(firing_rates, cfs):
        tuning_curves.append(fit_tuning_curve(levels, freqs, fr, 1.05, cf))
    # Save tuning curves to disk (note because different curves can have different lengths, we save as object array)
    np.save(os.path.join('nofigure/tuning_curves/', model_name + '_tuning_curves' + '.npy'),
            np.array(tuning_curves, dtype='object'))
