"""
This script implements the simulations described in Figure 5 of Guest and Oxenham (2021).
"""
import apcmodels.simulation as si
import apcmodels.anf as anf
from apcmodels.decode import *
from apcmodels.util import save_to_csv
import numpy as np
import os, sys
sys.path.append(os.getcwd())
from util.functions import ISOToneGuest2021_exp1a, adjust_level
import warnings
warnings.filterwarnings('ignore')
import matplotlib.pyplot as plt


def decode_ideal_observer(ratefunc):
    """ Decode response by estimating thresholds for an ideal observer.

    Estimates thresholds for a particular parameter in a set of parameters based on simulated responses to those
    parameters. Implemented as a wrapper that can be applied to any ratefunc that accepts a dict of parameter names
    and values (params) and returns a single firing rate simulation of appropriate shape.

    The basic approach is as follows. We assume that, instead of encoding a single simulation as a dict of parameter
    names and values (as any Simulator's simulate() method or ratefunc would assume), multiple simulations have been
    encoded as a (possibly nested) list of such dicts. We refer to this as params (see below). The neural rate response
    is simulated for each encoded set of parameters using ratefunc. Then, ideal observer thresholds are derived from
    these simulated rate responses.

    decode_ideal_observer() supports a range of structures for params, each of which maps onto a particular mathematical
    operation:
        1. In the simplest form, params is a list with two elements. The first element should be a dict encoding a
            baseline simulation while the second element should be a dict encoding an "incremented" simulation (i.e., a
            single parameter has been very slightly increased). The firing rate responses generated by these two
            simulations are then used in the finite differences method to estimate a partial derivative of the firing
            rate waveform with respect to the parameter incremented. This type of params list can be generated using
            the simulation.increment_parameters() function.
        2. In a slightly more complex form, params can be a list with multiple elements. The first element should
            again encode a baseline simulation while each following element should encode an incremented simulation,
            each with respect to a different parameter. These generate firing rate responses are then used to estimate
            partial derivatives with respect to each incremented parameter. This type of params list can be generated
            using the simulation.increment_parameters() function.
        3. Finally, params can be a nested list (two levels deep). Each element is a list as in (1) or (2) and are
            assumed to be draws from a random distribution governing some parameters encoded in the dicts (i.e., at
            least one or more encoded parameters should be random variables instantiated as lambda functions instead of
            fixed values). In this case, the partial derivatives are estimated for each element in params and then
            averaged later to estimate an expected partial derivative. This type of params list can be generated using
            the simulation.increment_parameters() function followed by the simulation.repeat_parameters() function.

    The mathematics underlying this function are described in Siebert (1970) and Heinz, Colburn, and Carney (2001), but
    are briefly presented here as well. The logic is that we assume that X_i (observed spike times for auditory nerve
    fiber i) are distributed X_i ~ Poisson(r_i(t, theta)), where r_i(t, theta) is the instantaneous firing rate of
    auditory nerve fiber i with parameters t (time) and theta (experimental parameters). theta is assumed to be
    distributed theta ~ rho(lambda) where rho is some parameter distribution governed by location parameter lambda. Then
    the precision of any unbiased estimator of theta is bounded above by E(I(theta)) + I(lambda), where I is the Fisher
    information matrix. When I(theta) is derived from a non-homogeneous Poisson distribution, we find that it depends
    on the derivative of r_i with respect to theta. We use computational simulations of r_i to estimate this derivative,
    and simple averaging to estimate its expectation over samples of theta. Finally, we take this upper bound and
    convert it into a threshold and return it.

    Args:
        ratefunc (function): a function that accepts **kwargs and returns firing rates for a neural simulation

    Returns:
        inner (function): the wrapped ratefunc

    References:
        Heinz, M. G., Colburn, H. S., & Carney, L. H. (2001). Evaluating auditory performance limits: I. One-parameter
        discrimination using a computational model for the auditory nerve. Neural computation, 13(10), 2273-2316.

        Siebert, W. M. (1970). Frequency discrimination in the auditory system: Place or periodicity mechanisms?.
        Proceedings of the IEEE, 58(5), 723-730.
    """
    def inner(params):
        """ Runs ratefunc on each input encoded in params and estimates ideal observer thresholds

        inner() runs ratefunc on each input/parameter set encoded in params. Then, it calculates ideal observer
        thresholds from those simulations. This requires some additional information to be encoded in params above and
        beyond a standard neural simulation. Namely, we need
            1. API (ndarray): An a priori information matrix (API)
            2. delta_theta (ndarray, list): a collection of values indicating how much various parameters were
                incremented
            3. n_fiber_per_chan (ndarray, list): a collection of values indicating how many fibers are "represented" at
                by each CF's rate response

        Args:
            params (list): a list (possibly nested) of dicts of parameter names and values

        Returns:
            thresholds (tuple): predicted all-information and rate-place thresholds
        """
        # Pull parameters from encoded list/dict of parameters
        fs = find_parameter(params, 'fs')
        delta_theta = find_parameter(params, 'delta_theta')
        n_fiber_per_chan = find_parameter(params, 'n_fiber_per_chan')
        API = find_parameter(params, 'API')

        # Run ratefunc on kwargs and get firing rates for each input
        rates = run_rates_util(ratefunc, params)

        # Check to see if the elements of rates are ndarrays or lists... if they are not lists, we need to put
        # rates inside a list so it can be processed by the list comprehension below
        if type(rates[0]) is not list:
            rates = [rates]

        # Compute partial derivative matrices for rates for AI and then RP
        pdms_AI = [compute_partial_derivative_matrix(x, fs, delta_theta, n_fiber_per_chan, 'AI') for x in rates]
        pdms_AI = np.array(pdms_AI)

        pdms_RP = [compute_partial_derivative_matrix(x, fs, delta_theta, n_fiber_per_chan, 'RP') for x in rates]
        pdms_RP = np.array(pdms_RP)

        # Return ideal observer results
        return pdms_AI, pdms_RP

    def compute_partial_derivative_matrix(x, fs, delta_theta, n_fiber_per_chan, _type):
        """ Computes a partial derivative matrix as in Siebert (1970) and Heinz et al. (2001)

        Args:
            x (list): list of ndarrays containing firing-rate simulations in shape (n_channel x n_sample). The first
                array should be a firing-rate simulation for baseline parameter values. The following arrays should
                be firing-rate simulations where a single parameter has been incremented by a small amount.
            fs (int): sampling rate in Hz
            delta_theta (ndarray): 1d ndarray containing the increment size for each element of x after the first
            n_fiber_per_chan (array): array containing integers of len n_cf, each element indicates how many fibers
                are theoretically represented by the single corresponding channel in x
            _type (str): either 'AI' or 'RP' for all-information or rate-place

        Returns:

        """
        # Calculate n_param
        n_param = len(x)-1
        if n_param < 1:
            raise ValueError('There is only one simulation per condition --- ideal observer needs n_param + 1 '
                             'simulations!')
        # Transform from list to ndarray
        x = np.array(x)
        x = np.transpose(x, [1, 0, 2])  # shape: n_cf x (n_param + 1) x n_sample
        # Add small baseline firing rate to avoid issues with zeros and NaNs
        x += 1
        # Construct one ndarray of baseline values and another of incremented values
        baseline = np.tile(x[:, 0, :], [n_param, 1, 1])
        baseline = np.transpose(baseline, [1, 0, 2])  # shape: n_cf x n_param x n_sample
        incremented = x[:, 1:, :]  # shape: n_cf x n_param x n_sample
        if _type == 'AI':
            # Estimate derivative with respect to each parameter
            deriv_estimate = np.transpose(np.transpose((incremented - baseline), [0, 2, 1]) / delta_theta, [0, 2, 1])  # shape: n_CF x n_param x n_time
            # Normalize the derivatives by the square root of rate
            deriv_norm = np.sqrt(1 / baseline) * deriv_estimate  # shape: n_CF x n_param x n_time
            # Compute derivative matrix
            deriv_matrix = 1 / fs * np.matmul(deriv_norm, np.transpose(deriv_norm, [0, 2, 1]))  # shape: n_CF x n_param x n_param
            # Sum across fibers
            deriv_matrix = np.sum(np.transpose(n_fiber_per_chan * np.transpose(deriv_matrix, [1, 2, 0]), [2, 0, 1]), axis=0)
            return deriv_matrix
        elif _type == 'RP':
            # Calculate the duration of the response
            t_max = baseline.shape[2] * 1/fs
            # Average results across time
            baseline = np.mean(baseline, axis=2)
            incremented = np.mean(incremented, axis=2)
            # Estimate derivative with respect to each parameter
            deriv_estimate = (incremented - baseline)/delta_theta
            # Normalize the derivatives by the square root of rate
            deriv_norm = np.sqrt(1 / baseline) * deriv_estimate  # shape: n_CF x n_param
            # Compute derivative matrix
            deriv_norm = np.stack((deriv_norm, deriv_norm), axis=2)
            deriv_matrix = np.matmul(deriv_norm, np.transpose(deriv_norm, [0, 2, 1]))  # shape: n_CF x n_param x n_param
            # Sum across fibers
            deriv_matrix = 0.5 * t_max * np.sum(n_fiber_per_chan * deriv_matrix, axis=0)  # shape: n_param x n_param
            return deriv_matrix

    return inner


def simulate_figure5_f0dls_phase_roving(F0s, levels, model, model_name, fs, n_rep=10):
    """
    Estimates F0 difference limens (F0DLs) using ideal observer analysis for a given auditory nerve model. Saves
    the results to disk. The simulations include phase randomization (specifically, each component from 6-10 has its
    starting phase randomized on each trial).

    Arguments:
        model: model object from apcmodels.anf

        model_name (str): name of the model

        fs (int): sampling rate in Hz

        n_rep (int): number of repetitions to perform for each simulation
    """
    # Define stimulus parameters
    dur = 0.10  # seconds
    dur_ramp = 0.01  # seconds

    # Define model parameters
    cf_low = 5*F0s
    cf_high = 11*F0s
    n_cf = 40
    n_fiber_per_chan = 40  # TODO: check this value

    # Encode parameters
    delta_theta = [0.001, 0.001, 0.001, 0.001, 0.001, 0.001]
    API = np.zeros((6, 6))
    API[np.diag_indices(6)] = [0, 1/360**2, 1/360**2, 1/360**2, 1/360**2, 1/360**2]
    params = {'dur': dur, 'dur_ramp': dur_ramp, 'fs': fs}  # encode fixed parameters in a dict
    params['phase'] = lambda: np.random.uniform(0, 360, 5)
    params = si.wiggle_parameters(params, 'F0', F0s)  # wiggle frequencies
    params = si.stitch_parameters(params, 'cf_low', cf_low)  # stitch cf_low (each F0 corresponds to a cf_low)
    params = si.stitch_parameters(params, 'cf_high', cf_high)  # stitch cf_high (each F0 corresponds to a cf_high)
    params = si.wiggle_parameters(params, 'level', levels)  # wiggle levels
    params = si.append_parameters(params, ['n_cf', 'delta_theta', 'API', 'n_fiber_per_chan', 'model_name'],
                                  [n_cf, delta_theta, API, n_fiber_per_chan, model_name])  # append other model parameters

    # Adjust levels to be in dB re: threshold
    params = si.flatten_parameters(params)  # flatten out params
    for ele in params:
        ele['nominal_level'] = ele['level']  # save the nominal level (dB re: threshold)
        ele['level'] = adjust_level(ele['F0']*8, ele['level'], model_name)  # encode the actual level (dB SPL)

    # Encode repeats and increments
    params = si.repeat_parameters(params, n_rep)
    params = si.increment_parameters(params, {'F0': 0.001,                                  # increment F0
                                              '(1)_phase': np.array([0.001, 0, 0, 0, 0]),   # increment phase of H6
                                              '(2)_phase': np.array([0, 0.001, 0, 0, 0]),   # increment phase of H7
                                              '(3)_phase': np.array([0, 0, 0.001, 0, 0]),   # increment phase of H8
                                              '(4)_phase': np.array([0, 0, 0, 0.001, 0]),   # increment phase of H9
                                              '(5)_phase': np.array([0, 0, 0, 0, 0.001])})  # increment phase of H10

    # Synthesize stimuli
    synth = ISOToneGuest2021_exp1a()
    stimuli = synth.synthesize_sequence(params)
    params = si.stitch_parameters(params, '_input', stimuli)

    # Construct simulation and run
    sim = model()
    results = sim.run(params, runfunc=decode_ideal_observer(sim.simulate))

    return results


def simulate_figure5_f0dls_level_roving(F0s, levels, model, model_name, fs, n_rep=10):
    """
    Estimates F0 difference limens (F0DLs) using ideal observer analysis for a given auditory nerve model. Saves
    the results to disk. Includes simulations of level roving.

    Arguments:
        model: model object from apcmodels.anf

        model_name (str): name of the model

        fs (int): sampling rate in Hz

        n_rep (int): number of repetitions to perform for each simulation
    """
    # Define stimulus parameters
    #levels = [lambda: np.random.uniform(17, 23, 5), lambda: np.random.uniform(27, 33, 5), lambda: np.random.uniform(37, 43, 5)]  # dB SL
    nominal_levels = [20, 30, 40]
    dur = 0.10  # seconds
    dur_ramp = 0.01  # seconds

    # Define model parameters
    cf_low = 5*F0s
    cf_high = 11*F0s
    n_cf = 40
    n_fiber_per_chan = 40  # TODO: check this value

    # Encode parameters
    delta_theta = [0.001, 0.001, 0.001, 0.001, 0.001, 0.001]
    API = np.zeros((6, 6))
    API[np.diag_indices(6)] = [0, 1/6**2, 1/6**2, 1/6**2, 1/6**2, 1/6**2]
    params = {'dur': dur, 'dur_ramp': dur_ramp, 'fs': fs}  # encode fixed parameters in a dict
    params = si.wiggle_parameters(params, 'F0', F0s)  # wiggle frequencies
    params = si.stitch_parameters(params, 'cf_low', cf_low)  # stitch cf_low (each F0 corresponds to a cf_low)
    params = si.stitch_parameters(params, 'cf_high', cf_high)  # stitch cf_high (each F0 corresponds to a cf_high)
    params = si.wiggle_parameters_parallel(params, ['level', 'nominal_level'], [levels, nominal_levels])  # wiggle levels
    params = si.append_parameters(params, ['n_cf', 'delta_theta', 'API', 'n_fiber_per_chan', 'model_name'],
                                  [n_cf, delta_theta, API, n_fiber_per_chan, model_name])  # append other model parameters

    # Adjust levels to be in dB re: threshold
    params = si.flatten_parameters(params)  # flatten out params

    # Encode repeats and increments
    params = si.repeat_parameters(params, n_rep)
    params = si.increment_parameters(params, {'F0': 0.001,                                  # increment F0
                                              '(1)_level': np.array([0.001, 0, 0, 0, 0]),   # increment level of H6
                                              '(2)_level': np.array([0, 0.001, 0, 0, 0]),   # increment level of H7
                                              '(3)_level': np.array([0, 0, 0.001, 0, 0]),   # increment level of H8
                                              '(4)_level': np.array([0, 0, 0, 0.001, 0]),   # increment level of H9
                                              '(5)_level': np.array([0, 0, 0, 0, 0.001])})  # increment level of H10

    # Adjust levels to be in dB re: threshold
    for ele in params:   # loop through elements of params
        for x in ele:    # loop through repeats of params
            for y in x:  # loop through increments of params
                y['level'] = adjust_level(y['F0']*8, y['level'], model_name)  # encode the actual level (dB SPL)

    # Synthesize stimuli
    synth = ISOToneGuest2021_exp1a()
    stimuli = synth.synthesize_sequence(params)
    params = si.stitch_parameters(params, '_input', stimuli)

    # Construct simulation and run
    sim = model()
    results = sim.run(params, runfunc=decode_ideal_observer(sim.simulate), parallel=True, hide_progress=False)

    return results


# Loop through models and calculate FDLs for each model
results = simulate_figure5_f0dls_phase_roving(np.array([300]), np.array([30]), anf.AuditoryNerveHeinz2001, 'Heinz2001',
                                              int(1000e3))
import matplotlib
fig, ax = plt.subplots(1, 1)
im = ax.imshow(results[0][0][0, :, :], norm=matplotlib.colors.SymLogNorm(linthresh=0.01, linscale=0.03, vmin=-10e5, vmax=10e5), cmap='RdBu')
fig.colorbar(im, ax=ax, extend='both')
plt.yticks([0, 1, 2, 3, 4, 5], ['F0', 'Phase (harmonic 6)', 'Phase (harmonic 7)', 'Phase (harmonic 8)', 'Phase (harmonic 9)', 'Phase (harmonic 10)'])
plt.xticks([0, 1, 2, 3, 4, 5], ['F0', 'Phase (harmonic 6)', 'Phase (harmonic 7)', 'Phase (harmonic 8)', 'Phase (harmonic 9)', 'Phase (harmonic 10)'], rotation=45, ha='right')
#rect = matplotlib.patches.Rectangle((-0.5, -0.5), 1, 1, linewidth=2, edgecolor='r', facecolor='none')
# Add the patch to the Axes
#ax.add_patch(rect)
plt.tight_layout()